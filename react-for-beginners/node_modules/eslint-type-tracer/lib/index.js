import * as module from "module";
import { findVariable, getStaticValue } from "@eslint-community/eslint-utils";

//#region src/type-tracer/utils.ts
/**
* Get the type of the given expression node.
* @param node The expression node.
* @returns `true` if should disallow it.
*/
function getSimpleExpressionType(node) {
	if (node.type === "ArrayExpression") return "Array";
	if (node.type === "Literal") {
		if ("regex" in node && node.regex) return "RegExp";
		if ("bigint" in node && node.bigint) return "BigInt";
		if (node.value === null) return "null";
		if (typeof node.value === "string") return "String";
		if (typeof node.value === "number") return "Number";
		if (typeof node.value === "boolean") return "Boolean";
		if (typeof node.value === "bigint") return "BigInt";
		if (node.value instanceof RegExp) return "RegExp";
		return null;
	}
	if (node.type === "TemplateLiteral") return "String";
	if (node.type === "UpdateExpression") return "Number";
	return null;
}

//#endregion
//#region src/type-tracer/type-tracer-for-ts.ts
let ts;
try {
	const require = module.createRequire(import.meta.url);
	ts = require("typescript");
} catch {}
/**
* Build type tracer.
* @returns Returns a type tracer.
*/
function buildTypeTracerForTS(sourceCode) {
	const trace = buildTypeTracer$1(sourceCode);
	if (!trace) return null;
	return function(node) {
		const type = getSimpleExpressionType(node);
		if (type) return [type];
		const result = [];
		trace(node, {
			visitTypeName(typeName) {
				result.push(typeName);
				return true;
			},
			visitUnknown() {
				return false;
			},
			visitSymbol(symbol, checker) {
				const name = checker.getFullyQualifiedName(symbol);
				if (!name) return false;
				if (name.startsWith("Readonly")) result.push(name.slice(8));
				else if (name === "CallableFunction") result.push("Function");
				else if (name === "IteratorObject") result.push("Iterator");
				else result.push(name);
				return false;
			}
		});
		return result;
	};
}
/**
* Build object type checker for TypeScript.
* @param context The rule context.
* @param aggressiveResult The value to return if the type cannot be determined.
* @returns Returns an object type checker. Returns null if TypeScript is not available.
*/
function buildTypeCheckerForTS(sourceCode, aggressiveResult = false) {
	const trace = buildTypeTracer$1(sourceCode);
	if (!trace) return null;
	return function(node, className, memberAccessNode) {
		const type = getSimpleExpressionType(node);
		if (type) return type === className;
		return trace(node, {
			visitTypeName(typeName) {
				return typeName === className;
			},
			visitUnknown() {
				return aggressiveResult;
			},
			visitSymbol(symbol, checker) {
				if (!className.includes(".")) {
					const escapedName = symbol.escapedName;
					return escapedName === className || escapedName === `Readonly${className}` || className === "Function" && escapedName === "CallableFunction" || className === "Iterator" && escapedName === "IteratorObject";
				}
				return checker.getFullyQualifiedName(symbol) === className;
			}
		}, memberAccessNode);
	};
}
/**
*
*/
function buildTypeTracer$1(sourceCode) {
	const tsNodeMap = sourceCode.parserServices.esTreeNodeToTSNodeMap;
	const checker = sourceCode.parserServices.program && sourceCode.parserServices.program.getTypeChecker();
	const isTS = Boolean(ts && tsNodeMap && checker);
	if (!isTS) return null;
	const hasFullType = sourceCode.parserServices.hasFullTypeInformation !== false;
	return (node, ctx, memberAccessNode) => {
		return memberAccessNode && checkByPropertyDeclaration(memberAccessNode, ctx) || checkByObjectExpressionType(node, ctx);
	};
	/**
	* Check if the type of the given node by the declaration of `node.property`.
	* @param memberAccessNode The MemberExpression or Property node.
	* @param ctx The trace context.
	* @returns a truthy value, if the process is complete.
	*/
	function checkByPropertyDeclaration(memberAccessNode, ctx) {
		const tsNode = tsNodeMap.get(memberAccessNode.type === "MemberExpression" ? memberAccessNode.property : memberAccessNode);
		const symbol = tsNode && checker.getSymbolAtLocation(tsNode);
		const declarations = symbol && symbol.declarations;
		if (declarations) for (const declaration of declarations) {
			if (declaration.parent.kind === ts.SyntaxKind.SourceFile) continue;
			const type = checker.getTypeAtLocation(declaration.parent);
			const r = type && visitType(type, ctx);
			if (r) return r;
		}
		return false;
	}
	/**
	* Check if the type of the given node by the type of `node.object`.
	* @param node The Expression node.
	* @param ctx The trace context.
	* @returns a truthy value, if the process is complete.
	*/
	function checkByObjectExpressionType(node, ctx) {
		const tsNode = tsNodeMap.get(node);
		const type = checker.getTypeAtLocation(tsNode);
		return visitType(type, ctx);
	}
	/**
	* Visit the type.
	* @param type The type to check.
	* @param ctx The trace context.
	* @returns a truthy value, if the process is complete.
	*/
	function visitType(type, ctx) {
		if (isFunction(type)) return ctx.visitTypeName("Function");
		if (isAny(type) || isUnknown(type)) return ctx.visitUnknown();
		if (isAnonymousObject(type)) return hasFullType ? false : ctx.visitUnknown();
		if (isStringLike(type)) return ctx.visitTypeName("String");
		if (isNumberLike(type)) return ctx.visitTypeName("Number");
		if (isBooleanLike(type)) return ctx.visitTypeName("Boolean");
		if (isBigIntLike(type)) return ctx.visitTypeName("BigInt");
		if (isSymbolLike(type)) return ctx.visitTypeName("Symbol");
		if (isArrayLikeObject(type)) return ctx.visitTypeName("Array");
		if (isReferenceObject(type) && type.target !== type) return visitType(type.target, ctx);
		if (isTypeParameter(type)) {
			const constraintType = getConstraintType(type);
			if (constraintType) return visitType(constraintType, ctx);
			return hasFullType ? false : ctx.visitUnknown();
		}
		if (isUnionOrIntersection(type)) {
			for (const t of type.types) {
				const r = visitType(t, ctx);
				if (r) return r;
			}
			return false;
		}
		if (isClassOrInterface(type)) return typeSymbolEscapedNameEquals(type, ctx);
		return ctx.visitTypeName(checker.typeToString(type));
	}
	/**
	* Check if the symbol.escapedName of the given type is expected or not.
	* @param type The type to check.
	* @param ctx The trace context.
	* @returns a truthy value, if the process is complete.
	*/
	function typeSymbolEscapedNameEquals(type, ctx) {
		const symbol = type.symbol;
		return ctx.visitSymbol(symbol, checker);
	}
	/**
	* Get the constraint type of a given type parameter type if exists.
	*
	* `type.getConstraint()` method doesn't return the constraint type of the
	* type parameter for some reason. So this gets the constraint type via AST.
	*
	* @param type The type parameter type to get.
	* @returns The constraint type.
	*/
	function getConstraintType(type) {
		const declaration = type.symbol?.declarations?.[0];
		if (declaration && ts.isTypeParameterDeclaration(declaration) && declaration.constraint != null) return checker.getTypeFromTypeNode(declaration.constraint);
		return void 0;
	}
}
/**
* Check if a given type is an anonymous object type or not.
* @param type The type to check.
* @returns `true` if the type is an anonymous object type.
*/
function isAnonymousObject(type) {
	return isObject(type) && (type.objectFlags & ts.ObjectFlags.Anonymous) !== 0;
}
/**
* Check if a given type is `any` or not.
* @param type The type to check.
* @returns `true` if the type is `any`.
*/
function isAny(type) {
	return (type.flags & ts.TypeFlags.Any) !== 0;
}
/**
* Check if a given type is an array-like type or not.
* @param type The type to check.
* @returns `true` if the type is an array-like type.
*/
function isArrayLikeObject(type) {
	return isObject(type) && (type.objectFlags & (ts.ObjectFlags.ArrayLiteral | ts.ObjectFlags.EvolvingArray | ts.ObjectFlags.Tuple)) !== 0;
}
/**
* Check if a given type is an interface type or not.
* @param type The type to check.
* @returns `true` if the type is an interface type.
*/
function isClassOrInterface(type) {
	return isObject(type) && (type.objectFlags & ts.ObjectFlags.ClassOrInterface) !== 0;
}
/**
* Check if a given type is an object type or not.
* @param type The type to check.
* @returns `true` if the type is an object type.
*/
function isObject(type) {
	return (type.flags & ts.TypeFlags.Object) !== 0;
}
/**
* Check if a given type is a reference type or not.
* @param type The type to check.
* @returns `true` if the type is a reference type.
*/
function isReferenceObject(type) {
	return isObject(type) && (type.objectFlags & ts.ObjectFlags.Reference) !== 0;
}
/**
* Check if a given type is a string-like type or not.
* @param type The type to check.
* @returns `true` if the type is a string-like type.
*/
function isStringLike(type) {
	return (type.flags & ts.TypeFlags.StringLike) !== 0;
}
/**
* Check if a given type is a number-like type or not.
* @param type The type to check.
* @returns `true` if the type is a number-like type.
*/
function isNumberLike(type) {
	return (type.flags & ts.TypeFlags.NumberLike) !== 0;
}
/**
* Check if a given type is a boolean-like type or not.
* @param type The type to check.
* @returns `true` if the type is a boolean-like type.
*/
function isBooleanLike(type) {
	return (type.flags & ts.TypeFlags.BooleanLike) !== 0;
}
/**
* Check if a given type is a bigint-like type or not.
* @param type The type to check.
* @returns `true` if the type is a bigint-like type.
*/
function isBigIntLike(type) {
	return (type.flags & ts.TypeFlags.BigIntLike) !== 0;
}
/**
* Check if a given type is a symbol-like type or not.
* @param type The type to check.
* @returns `true` if the type is a symbol-like type.
*/
function isSymbolLike(type) {
	return (type.flags & ts.TypeFlags.ESSymbolLike) !== 0;
}
/**
* Check if a given type is a type parameter type or not.
* @param type The type to check.
* @returns `true` if the type is a type parameter type.
*/
function isTypeParameter(type) {
	return (type.flags & ts.TypeFlags.TypeParameter) !== 0;
}
/**
* Check if a given type is a union-or-intersection type or not.
* @param type The type to check.
* @returns `true` if the type is a union-or-intersection type.
*/
function isUnionOrIntersection(type) {
	return (type.flags & ts.TypeFlags.UnionOrIntersection) !== 0;
}
/**
* Check if a given type is `unknown` or not.
* @param type The type to check.
* @returns `true` if the type is `unknown`.
*/
function isUnknown(type) {
	return (type.flags & ts.TypeFlags.Unknown) !== 0;
}
/**
* Check if a given type is `function` or not.
* @param type The type to check.
* @returns `true` if the type is `function`.
*/
function isFunction(type) {
	if (type.symbol && (type.symbol.flags & (ts.SymbolFlags.Function | ts.SymbolFlags.Method)) !== 0) return true;
	const signatures = type.getCallSignatures();
	return signatures.length > 0;
}

//#endregion
//#region src/type-tracer/es-types.ts
const RETURN_STRING = {
	type: "Function",
	return: { type: "String" }
};
const RETURN_NUMBER = {
	type: "Function",
	return: { type: "Number" }
};
const RETURN_BOOLEAN = {
	type: "Function",
	return: { type: "Boolean" }
};
const WELLKNOWN_GLOBALS = {
	String: {
		...RETURN_STRING,
		prototypeType: "String",
		properties: {
			fromCharCode: RETURN_STRING,
			fromCodePoint: RETURN_STRING,
			raw: RETURN_STRING
		}
	},
	Number: {
		...RETURN_NUMBER,
		prototypeType: "Number",
		properties: {
			EPSILON: { type: "Number" },
			MAX_SAFE_INTEGER: { type: "Number" },
			MAX_VALUE: { type: "Number" },
			MIN_SAFE_INTEGER: { type: "Number" },
			MIN_VALUE: { type: "Number" },
			NaN: { type: "Number" },
			NEGATIVE_INFINITY: { type: "Number" },
			POSITIVE_INFINITY: { type: "Number" },
			isFinite: RETURN_BOOLEAN,
			isInteger: RETURN_BOOLEAN,
			isNaN: RETURN_BOOLEAN,
			isSafeInteger: RETURN_BOOLEAN,
			parseFloat: RETURN_NUMBER,
			parseInt: RETURN_NUMBER
		}
	},
	Boolean: {
		...RETURN_BOOLEAN,
		prototypeType: "Boolean",
		properties: {}
	},
	Symbol: {
		type: "Function",
		return: { type: "Symbol" },
		prototypeType: "Symbol",
		properties: {
			for: {
				type: "Function",
				return: { type: "Symbol" }
			},
			keyFor: RETURN_STRING,
			asyncIterator: { type: "Symbol" },
			hasInstance: { type: "Symbol" },
			isConcatSpreadable: { type: "Symbol" },
			iterator: { type: "Symbol" },
			match: { type: "Symbol" },
			matchAll: { type: "Symbol" },
			replace: { type: "Symbol" },
			search: { type: "Symbol" },
			species: { type: "Symbol" },
			split: { type: "Symbol" },
			toPrimitive: { type: "Symbol" },
			toStringTag: { type: "Symbol" },
			unscopables: { type: "Symbol" },
			dispose: { type: "Symbol" },
			asyncDispose: { type: "Symbol" },
			metadata: { type: "Symbol" },
			observable: { type: "Symbol" }
		}
	},
	BigInt: {
		type: "Function",
		return: { type: "BigInt" },
		prototypeType: "BigInt",
		properties: {
			asIntN: {
				type: "Function",
				return: { type: "BigInt" }
			},
			asUintN: {
				type: "Function",
				return: { type: "BigInt" }
			}
		}
	},
	Object: {
		type: "Function",
		return: { type: "Object" },
		prototypeType: "Object",
		properties: {
			assign: {
				type: "Function",
				return: { type: "Object" }
			},
			create: {
				type: "Function",
				return: { type: "Object" }
			},
			defineProperties: {
				type: "Function",
				return: { type: "Object" }
			},
			defineProperty: {
				type: "Function",
				return: { type: "Object" }
			},
			entries: {
				type: "Function",
				return: { type: "Array" }
			},
			freeze: {
				type: "Function",
				return: { type: "Object" }
			},
			fromEntries: {
				type: "Function",
				return: { type: "Object" }
			},
			getOwnPropertyDescriptor: {
				type: "Function",
				return: { type: "Object" }
			},
			getOwnPropertyDescriptors: {
				type: "Function",
				return: { type: "Object" }
			},
			getOwnPropertyNames: {
				type: "Function",
				return: { type: "Array" }
			},
			getOwnPropertySymbols: {
				type: "Function",
				return: { type: "Array" }
			},
			getPrototypeOf: {
				type: "Function",
				return: { type: "Object" }
			},
			groupBy: {
				type: "Function",
				return: { type: "Object" }
			},
			hasOwn: RETURN_BOOLEAN,
			is: RETURN_BOOLEAN,
			isExtensible: RETURN_BOOLEAN,
			isFrozen: RETURN_BOOLEAN,
			isSealed: RETURN_BOOLEAN,
			keys: {
				type: "Function",
				return: { type: "Array" }
			},
			preventExtensions: {
				type: "Function",
				return: { type: "Object" }
			},
			seal: {
				type: "Function",
				return: { type: "Object" }
			},
			setPrototypeOf: {
				type: "Function",
				return: { type: "Object" }
			},
			values: {
				type: "Function",
				return: { type: "Array" }
			},
			prototype: { type: "Object" }
		}
	},
	Function: {
		type: "Function",
		return: { type: "Function" },
		prototypeType: "Function",
		properties: {}
	},
	Array: {
		type: "Function",
		return: { type: "Array" },
		prototypeType: "Array",
		properties: {
			from: {
				type: "Function",
				return: { type: "Array" }
			},
			fromAsync: {
				type: "Function",
				return: { type: "Promise" }
			},
			isArray: RETURN_BOOLEAN,
			of: {
				type: "Function",
				return: { type: "Array" }
			},
			get [Symbol.species]() {
				return WELLKNOWN_GLOBALS.Array;
			}
		}
	},
	Map: {
		type: "Function",
		return: { type: "Map" },
		prototypeType: "Map",
		properties: {
			groupBy: {
				type: "Function",
				return: { type: "Map" }
			},
			get [Symbol.species]() {
				return WELLKNOWN_GLOBALS.Map;
			}
		}
	},
	Set: {
		type: "Function",
		return: { type: "Set" },
		prototypeType: "Set",
		properties: { get [Symbol.species]() {
			return WELLKNOWN_GLOBALS.Set;
		} }
	},
	RegExp: {
		type: "Function",
		return: { type: "RegExp" },
		prototypeType: "RegExp",
		properties: {
			escape: {
				type: "Function",
				return: { type: "String" }
			},
			"$&": { type: "String" },
			"$'": { type: "String" },
			"$`": { type: "String" },
			"$+": { type: "String" },
			$_: { type: "String" },
			$1: { type: "String" },
			$2: { type: "String" },
			$3: { type: "String" },
			$4: { type: "String" },
			$5: { type: "String" },
			$6: { type: "String" },
			$7: { type: "String" },
			$8: { type: "String" },
			$9: { type: "String" },
			input: { type: "String" },
			lastMatch: { type: "String" },
			lastParen: { type: "String" },
			leftContext: { type: "String" },
			rightContext: { type: "String" },
			get [Symbol.species]() {
				return WELLKNOWN_GLOBALS.RegExp;
			}
		}
	},
	Date: {
		type: "Function",
		return: { type: "Date" },
		prototypeType: "Date",
		properties: {
			now: {
				type: "Function",
				return: { type: "Number" }
			},
			parse: {
				type: "Function",
				return: { type: "Number" }
			},
			UTC: {
				type: "Function",
				return: { type: "Number" }
			}
		}
	},
	Promise: {
		type: "Function",
		return: { type: "Promise" },
		prototypeType: "Promise",
		properties: {
			all: {
				type: "Function",
				return: { type: "Promise" }
			},
			allSettled: {
				type: "Function",
				return: { type: "Promise" }
			},
			any: {
				type: "Function",
				return: { type: "Promise" }
			},
			race: {
				type: "Function",
				return: { type: "Promise" }
			},
			reject: {
				type: "Function",
				return: { type: "Promise" }
			},
			resolve: {
				type: "Function",
				return: { type: "Promise" }
			},
			try: {
				type: "Function",
				return: { type: "Promise" }
			},
			withResolvers: {
				type: "Function",
				return: {
					type: "Object",
					properties: {
						promise: { type: "Promise" },
						resolve: { type: "Function" },
						reject: { type: "Function" }
					}
				}
			},
			get [Symbol.species]() {
				return WELLKNOWN_GLOBALS.Promise;
			}
		}
	},
	Int8Array: buildGlobalTypedArrayTypeInfo("Int8Array"),
	Uint8Array: buildGlobalTypedArrayTypeInfo("Uint8Array", {
		fromBase64: { type: "Function" },
		fromHex: { type: "Function" }
	}),
	Uint8ClampedArray: buildGlobalTypedArrayTypeInfo("Uint8ClampedArray"),
	Int16Array: buildGlobalTypedArrayTypeInfo("Int16Array"),
	Uint16Array: buildGlobalTypedArrayTypeInfo("Uint16Array"),
	Int32Array: buildGlobalTypedArrayTypeInfo("Int32Array"),
	Uint32Array: buildGlobalTypedArrayTypeInfo("Uint32Array"),
	Float16Array: buildGlobalTypedArrayTypeInfo("Float16Array"),
	Float32Array: buildGlobalTypedArrayTypeInfo("Float32Array"),
	Float64Array: buildGlobalTypedArrayTypeInfo("Float64Array"),
	BigInt64Array: buildGlobalTypedArrayTypeInfo("BigInt64Array"),
	BigUint64Array: buildGlobalTypedArrayTypeInfo("BigUint64Array"),
	DataView: {
		type: "Function",
		return: { type: "DataView" },
		prototypeType: "DataView",
		properties: {}
	},
	ArrayBuffer: {
		type: "Function",
		return: { type: "ArrayBuffer" },
		prototypeType: "ArrayBuffer",
		properties: {
			isView: RETURN_BOOLEAN,
			get [Symbol.species]() {
				return WELLKNOWN_GLOBALS.ArrayBuffer;
			}
		}
	},
	SharedArrayBuffer: {
		type: "Function",
		return: { type: "SharedArrayBuffer" },
		prototypeType: "SharedArrayBuffer",
		properties: {}
	},
	WeakMap: {
		type: "Function",
		return: { type: "WeakMap" },
		prototypeType: "WeakMap",
		properties: {}
	},
	WeakSet: {
		type: "Function",
		return: { type: "WeakSet" },
		prototypeType: "WeakSet",
		properties: {}
	},
	Intl: {
		type: "Object",
		properties: {
			Collator: {
				type: "Function",
				return: { type: "Intl.Collator" },
				prototypeType: "Intl.Collator"
			},
			DateTimeFormat: {
				type: "Function",
				return: { type: "Intl.DateTimeFormat" },
				prototypeType: "Intl.DateTimeFormat"
			},
			ListFormat: {
				type: "Function",
				return: { type: "Intl.ListFormat" },
				prototypeType: "Intl.ListFormat"
			},
			NumberFormat: {
				type: "Function",
				return: { type: "Intl.NumberFormat" },
				prototypeType: "Intl.NumberFormat"
			},
			PluralRules: {
				type: "Function",
				return: { type: "Intl.PluralRules" },
				prototypeType: "Intl.PluralRules"
			},
			RelativeTimeFormat: {
				type: "Function",
				return: { type: "Intl.RelativeTimeFormat" },
				prototypeType: "Intl.RelativeTimeFormat"
			},
			Segmenter: {
				type: "Function",
				return: { type: "Intl.Segmenter" },
				prototypeType: "Intl.Segmenter"
			},
			DisplayNames: {
				type: "Function",
				return: { type: "Intl.DisplayNames" },
				prototypeType: "Intl.DisplayNames"
			},
			DurationFormat: {
				type: "Function",
				return: { type: "Intl.DurationFormat" },
				prototypeType: "Intl.DurationFormat"
			},
			Locale: {
				type: "Function",
				return: { type: "Intl.Locale" },
				prototypeType: "Intl.Locale"
			},
			getCanonicalLocales: {
				type: "Function",
				return: { type: "Array" }
			},
			supportedValuesOf: {
				type: "Function",
				return: { type: "Array" }
			}
		}
	},
	Iterator: {
		type: "Function",
		return: { type: "Iterator" },
		prototypeType: "Iterator",
		properties: { from: {
			type: "Function",
			return: { type: "Iterator" }
		} }
	},
	DisposableStack: {
		type: "Function",
		return: { type: "DisposableStack" },
		prototypeType: "DisposableStack",
		properties: {}
	},
	AsyncDisposableStack: {
		type: "Function",
		return: { type: "AsyncDisposableStack" },
		prototypeType: "AsyncDisposableStack",
		properties: {}
	},
	WeakRef: {
		type: "Function",
		return: { type: "WeakRef" },
		prototypeType: "WeakRef",
		properties: {}
	},
	FinalizationRegistry: {
		type: "Function",
		return: { type: "FinalizationRegistry" },
		prototypeType: "FinalizationRegistry",
		properties: {}
	},
	undefined: { type: "undefined" },
	NaN: { type: "Number" },
	Infinity: { type: "Number" },
	Math: {
		type: "Object",
		properties: {
			abs: {
				type: "Function",
				return: { type: "Number" }
			},
			acos: {
				type: "Function",
				return: { type: "Number" }
			},
			acosh: {
				type: "Function",
				return: { type: "Number" }
			},
			asin: {
				type: "Function",
				return: { type: "Number" }
			},
			asinh: {
				type: "Function",
				return: { type: "Number" }
			},
			atan: {
				type: "Function",
				return: { type: "Number" }
			},
			atan2: {
				type: "Function",
				return: { type: "Number" }
			},
			atanh: {
				type: "Function",
				return: { type: "Number" }
			},
			cbrt: {
				type: "Function",
				return: { type: "Number" }
			},
			ceil: {
				type: "Function",
				return: { type: "Number" }
			},
			clz32: {
				type: "Function",
				return: { type: "Number" }
			},
			cos: {
				type: "Function",
				return: { type: "Number" }
			},
			cosh: {
				type: "Function",
				return: { type: "Number" }
			},
			exp: {
				type: "Function",
				return: { type: "Number" }
			},
			expm1: {
				type: "Function",
				return: { type: "Number" }
			},
			f16round: {
				type: "Function",
				return: { type: "Number" }
			},
			floor: {
				type: "Function",
				return: { type: "Number" }
			},
			fround: {
				type: "Function",
				return: { type: "Number" }
			},
			hypot: {
				type: "Function",
				return: { type: "Number" }
			},
			imul: {
				type: "Function",
				return: { type: "Number" }
			},
			log: {
				type: "Function",
				return: { type: "Number" }
			},
			log1p: {
				type: "Function",
				return: { type: "Number" }
			},
			log10: {
				type: "Function",
				return: { type: "Number" }
			},
			log2: {
				type: "Function",
				return: { type: "Number" }
			},
			max: {
				type: "Function",
				return: { type: "Number" }
			},
			min: {
				type: "Function",
				return: { type: "Number" }
			},
			pow: {
				type: "Function",
				return: { type: "Number" }
			},
			random: {
				type: "Function",
				return: { type: "Number" }
			},
			round: {
				type: "Function",
				return: { type: "Number" }
			},
			sign: {
				type: "Function",
				return: { type: "Number" }
			},
			sin: {
				type: "Function",
				return: { type: "Number" }
			},
			sinh: {
				type: "Function",
				return: { type: "Number" }
			},
			sqrt: {
				type: "Function",
				return: { type: "Number" }
			},
			sumPrecise: {
				type: "Function",
				return: { type: "Number" }
			},
			tan: {
				type: "Function",
				return: { type: "Number" }
			},
			tanh: {
				type: "Function",
				return: { type: "Number" }
			},
			trunc: {
				type: "Function",
				return: { type: "Number" }
			},
			E: { type: "Number" },
			LN2: { type: "Number" },
			LN10: { type: "Number" },
			LOG2E: { type: "Number" },
			LOG10E: { type: "Number" },
			PI: { type: "Number" },
			SQRT1_2: { type: "Number" },
			SQRT2: { type: "Number" },
			[Symbol.toStringTag]: { type: "String" }
		}
	},
	Error: {
		type: "Function",
		return: { type: "Error" },
		prototypeType: "Error",
		properties: {
			isError: {
				type: "Function",
				return: { type: "Boolean" }
			},
			captureStackTrace: { type: "Function" },
			stackTraceLimit: { type: "Number" }
		}
	},
	Atomics: {
		type: "Object",
		properties: {
			add: RETURN_NUMBER,
			and: RETURN_NUMBER,
			compareExchange: RETURN_NUMBER,
			exchange: RETURN_NUMBER,
			isLockFree: RETURN_BOOLEAN,
			load: RETURN_NUMBER,
			notify: RETURN_NUMBER,
			or: RETURN_NUMBER,
			store: RETURN_NUMBER,
			sub: RETURN_NUMBER,
			wait: RETURN_STRING,
			waitAsync: {
				type: "Function",
				return: {
					type: "Object",
					properties: { async: { type: "Boolean" } }
				}
			},
			xor: RETURN_NUMBER,
			pause: { type: "Function" },
			[Symbol.toStringTag]: { type: "String" }
		}
	}
};
const OBJECT_PROTOTYPE = {
	constructor: { type: "Function" },
	toString: RETURN_STRING,
	toLocaleString: RETURN_STRING,
	valueOf: { type: "Function" },
	hasOwnProperty: RETURN_BOOLEAN,
	isPrototypeOf: RETURN_BOOLEAN,
	propertyIsEnumerable: RETURN_BOOLEAN
};
const ARRAY_PROPERTIES = {
	at: { type: "Function" },
	concat: {
		type: "Function",
		return: { type: "Array" }
	},
	copyWithin: {
		type: "Function",
		return: { type: "Array" }
	},
	entries: {
		type: "Function",
		return: { type: "Iterator" }
	},
	every: RETURN_BOOLEAN,
	fill: {
		type: "Function",
		return: { type: "Array" }
	},
	filter: {
		type: "Function",
		return: { type: "Array" }
	},
	find: { type: "Function" },
	findIndex: RETURN_NUMBER,
	findLast: { type: "Function" },
	findLastIndex: RETURN_NUMBER,
	flat: {
		type: "Function",
		return: { type: "Array" }
	},
	flatMap: {
		type: "Function",
		return: { type: "Array" }
	},
	forEach: { type: "Function" },
	includes: RETURN_BOOLEAN,
	indexOf: RETURN_NUMBER,
	join: RETURN_STRING,
	keys: {
		type: "Function",
		return: { type: "Iterator" }
	},
	lastIndexOf: RETURN_NUMBER,
	map: {
		type: "Function",
		return: { type: "Array" }
	},
	pop: { type: "Function" },
	push: { type: "Function" },
	reduce: { type: "Function" },
	reduceRight: { type: "Function" },
	reverse: {
		type: "Function",
		return: { type: "Array" }
	},
	shift: { type: "Function" },
	slice: {
		type: "Function",
		return: { type: "Array" }
	},
	some: RETURN_BOOLEAN,
	sort: {
		type: "Function",
		return: { type: "Array" }
	},
	splice: {
		type: "Function",
		return: { type: "Array" }
	},
	toReversed: {
		type: "Function",
		return: { type: "Array" }
	},
	toSorted: {
		type: "Function",
		return: { type: "Array" }
	},
	toSpliced: {
		type: "Function",
		return: { type: "Array" }
	},
	unshift: { type: "Function" },
	values: {
		type: "Function",
		return: { type: "Iterator" }
	},
	with: {
		type: "Function",
		return: { type: "Array" }
	},
	length: { type: "Number" },
	[Symbol.iterator]: {
		type: "Function",
		return: { type: "Iterator" }
	},
	[Symbol.unscopables]: { type: "Object" }
};
const REGEXP_ARRAY_PROPERTIES = new Proxy({
	...ARRAY_PROPERTIES,
	index: { type: "Number" },
	input: { type: "String" },
	groups: { type: "Object" },
	indices: { type: "Array" },
	at: {
		type: "Function",
		return: { type: "String" }
	}
}, { get(target, propertyName) {
	if (isFinite(Number(propertyName))) return { type: "String" };
	const key = propertyName;
	return target[key];
} });
const WELLKNOWN_PROTOTYPE = {
	String: {
		anchor: RETURN_STRING,
		big: RETURN_STRING,
		blink: RETURN_STRING,
		bold: RETURN_STRING,
		fixed: RETURN_STRING,
		fontcolor: RETURN_STRING,
		fontsize: RETURN_STRING,
		italics: RETURN_STRING,
		link: RETURN_STRING,
		small: RETURN_STRING,
		strike: RETURN_STRING,
		sub: RETURN_STRING,
		sup: RETURN_STRING,
		charAt: RETURN_STRING,
		at: RETURN_STRING,
		charCodeAt: RETURN_NUMBER,
		codePointAt: RETURN_NUMBER,
		concat: RETURN_STRING,
		endsWith: RETURN_BOOLEAN,
		includes: RETURN_BOOLEAN,
		indexOf: RETURN_NUMBER,
		lastIndexOf: RETURN_NUMBER,
		localeCompare: RETURN_NUMBER,
		match: {
			type: "Function",
			return: { type: "Array" }
		},
		matchAll: {
			type: "Function",
			return: { type: "Iterator" }
		},
		normalize: RETURN_STRING,
		padEnd: RETURN_STRING,
		padStart: RETURN_STRING,
		repeat: RETURN_STRING,
		replace: RETURN_STRING,
		replaceAll: RETURN_STRING,
		search: RETURN_NUMBER,
		slice: RETURN_STRING,
		split: {
			type: "Function",
			return: { type: "Array" }
		},
		startsWith: RETURN_BOOLEAN,
		substr: RETURN_STRING,
		substring: RETURN_STRING,
		toLowerCase: RETURN_STRING,
		toLocaleLowerCase: RETURN_STRING,
		toUpperCase: RETURN_STRING,
		toLocaleUpperCase: RETURN_STRING,
		trim: RETURN_STRING,
		trimEnd: RETURN_STRING,
		trimLeft: RETURN_STRING,
		trimRight: RETURN_STRING,
		trimStart: RETURN_STRING,
		valueOf: RETURN_STRING,
		isWellFormed: RETURN_BOOLEAN,
		toWellFormed: RETURN_STRING,
		length: { type: "Number" },
		[Symbol.iterator]: {
			type: "Function",
			return: { type: "Iterator" }
		}
	},
	Number: {
		toExponential: RETURN_STRING,
		toFixed: RETURN_STRING,
		toPrecision: RETURN_STRING,
		valueOf: RETURN_NUMBER
	},
	Boolean: { valueOf: { type: "Boolean" } },
	Symbol: {
		description: { type: "String" },
		valueOf: { type: "Symbol" },
		[Symbol.toStringTag]: { type: "String" },
		[Symbol.toPrimitive]: {
			type: "Function",
			return: { type: "Symbol" }
		}
	},
	BigInt: {
		valueOf: { type: "BigInt" },
		[Symbol.toStringTag]: { type: "String" }
	},
	Function: {
		apply: { type: "Function" },
		bind: {
			type: "Function",
			return: { type: "Function" }
		},
		call: { type: "Function" },
		arguments: { type: "Object" },
		caller: { type: "Function" },
		length: { type: "Number" },
		name: { type: "String" },
		prototype: { type: "Object" },
		[Symbol.hasInstance]: {
			type: "Function",
			return: { type: "Boolean" }
		},
		[Symbol.metadata]: { type: "Object" }
	},
	Array: ARRAY_PROPERTIES,
	Map: {
		clear: { type: "Function" },
		delete: RETURN_BOOLEAN,
		entries: {
			type: "Function",
			return: { type: "Iterator" }
		},
		forEach: { type: "Function" },
		get: { type: "Function" },
		has: RETURN_BOOLEAN,
		keys: {
			type: "Function",
			return: { type: "Iterator" }
		},
		set: { type: "Function" },
		values: {
			type: "Function",
			return: { type: "Iterator" }
		},
		size: { type: "Number" },
		[Symbol.iterator]: {
			type: "Function",
			return: { type: "Iterator" }
		},
		[Symbol.toStringTag]: { type: "String" }
	},
	Set: {
		add: { type: "Function" },
		clear: { type: "Function" },
		delete: RETURN_BOOLEAN,
		difference: {
			type: "Function",
			return: { type: "Set" }
		},
		entries: {
			type: "Function",
			return: { type: "Iterator" }
		},
		forEach: { type: "Function" },
		has: RETURN_BOOLEAN,
		intersection: {
			type: "Function",
			return: { type: "Set" }
		},
		isDisjointFrom: RETURN_BOOLEAN,
		isSubsetOf: RETURN_BOOLEAN,
		isSupersetOf: RETURN_BOOLEAN,
		keys: {
			type: "Function",
			return: { type: "Iterator" }
		},
		symmetricDifference: {
			type: "Function",
			return: { type: "Set" }
		},
		union: {
			type: "Function",
			return: { type: "Set" }
		},
		values: {
			type: "Function",
			return: { type: "Iterator" }
		},
		size: { type: "Number" },
		[Symbol.iterator]: {
			type: "Function",
			return: { type: "Iterator" }
		},
		[Symbol.toStringTag]: { type: "String" }
	},
	RegExp: {
		compile: { type: "Function" },
		test: RETURN_BOOLEAN,
		exec: {
			type: "Function",
			return: {
				type: "Array",
				properties: REGEXP_ARRAY_PROPERTIES
			}
		},
		dotAll: { type: "Boolean" },
		flags: { type: "String" },
		global: { type: "Boolean" },
		hasIndices: { type: "Boolean" },
		ignoreCase: { type: "Boolean" },
		lastIndex: { type: "Number" },
		multiline: { type: "Boolean" },
		source: { type: "String" },
		sticky: { type: "Boolean" },
		unicode: { type: "Boolean" },
		unicodeSets: { type: "Boolean" },
		[Symbol.match]: {
			type: "Function",
			return: { type: "RegExp" }
		},
		[Symbol.replace]: {
			type: "Function",
			return: { type: "String" }
		},
		[Symbol.search]: {
			type: "Function",
			return: { type: "Number" }
		},
		[Symbol.split]: {
			type: "Function",
			return: {
				type: "Array",
				properties: REGEXP_ARRAY_PROPERTIES
			}
		},
		[Symbol.matchAll]: {
			type: "Function",
			return: {
				type: "Iterator",
				properties: REGEXP_ARRAY_PROPERTIES
			}
		}
	},
	Date: {
		getDate: RETURN_NUMBER,
		getDay: RETURN_NUMBER,
		getFullYear: RETURN_NUMBER,
		getHours: RETURN_NUMBER,
		getMilliseconds: RETURN_NUMBER,
		getMinutes: RETURN_NUMBER,
		getMonth: RETURN_NUMBER,
		getSeconds: RETURN_NUMBER,
		getTime: RETURN_NUMBER,
		getTimezoneOffset: RETURN_NUMBER,
		getUTCDate: RETURN_NUMBER,
		getUTCDay: RETURN_NUMBER,
		getUTCFullYear: RETURN_NUMBER,
		getUTCHours: RETURN_NUMBER,
		getUTCMilliseconds: RETURN_NUMBER,
		getUTCMinutes: RETURN_NUMBER,
		getUTCMonth: RETURN_NUMBER,
		getUTCSeconds: RETURN_NUMBER,
		getYear: RETURN_NUMBER,
		setDate: RETURN_NUMBER,
		setFullYear: RETURN_NUMBER,
		setHours: RETURN_NUMBER,
		setMilliseconds: RETURN_NUMBER,
		setMinutes: RETURN_NUMBER,
		setMonth: RETURN_NUMBER,
		setSeconds: RETURN_NUMBER,
		setTime: RETURN_NUMBER,
		setUTCDate: RETURN_NUMBER,
		setUTCFullYear: RETURN_NUMBER,
		setUTCHours: RETURN_NUMBER,
		setUTCMilliseconds: RETURN_NUMBER,
		setUTCMinutes: RETURN_NUMBER,
		setUTCMonth: RETURN_NUMBER,
		setUTCSeconds: RETURN_NUMBER,
		setYear: RETURN_NUMBER,
		toDateString: RETURN_STRING,
		toISOString: RETURN_STRING,
		toJSON: RETURN_STRING,
		toGMTString: RETURN_STRING,
		toLocaleDateString: RETURN_STRING,
		toLocaleTimeString: RETURN_STRING,
		toTimeString: RETURN_STRING,
		toUTCString: RETURN_STRING,
		valueOf: RETURN_NUMBER,
		[Symbol.toPrimitive]: {
			type: "Function",
			return: { type: "Date" }
		}
	},
	Promise: {
		catch: {
			type: "Function",
			return: { type: "Promise" }
		},
		finally: {
			type: "Function",
			return: { type: "Promise" }
		},
		then: {
			type: "Function",
			return: { type: "Promise" }
		},
		[Symbol.toStringTag]: { type: "String" }
	},
	Int8Array: buildTypedArrayPrototypeTypeInfo("Int8Array"),
	Uint8Array: buildTypedArrayPrototypeTypeInfo("Uint8Array", {
		toBase64: {
			type: "Function",
			return: { type: "String" }
		},
		toHex: {
			type: "Function",
			return: { type: "String" }
		},
		setFromBase64: { type: "Function" },
		setFromHex: { type: "Function" }
	}),
	Uint8ClampedArray: buildTypedArrayPrototypeTypeInfo("Uint8ClampedArray"),
	Int16Array: buildTypedArrayPrototypeTypeInfo("Int16Array"),
	Uint16Array: buildTypedArrayPrototypeTypeInfo("Uint16Array"),
	Int32Array: buildTypedArrayPrototypeTypeInfo("Int32Array"),
	Uint32Array: buildTypedArrayPrototypeTypeInfo("Uint32Array"),
	Float16Array: buildTypedArrayPrototypeTypeInfo("Float16Array"),
	Float32Array: buildTypedArrayPrototypeTypeInfo("Float32Array"),
	Float64Array: buildTypedArrayPrototypeTypeInfo("Float64Array"),
	BigInt64Array: buildTypedArrayPrototypeTypeInfo("BigInt64Array"),
	BigUint64Array: buildTypedArrayPrototypeTypeInfo("BigUint64Array"),
	DataView: {
		getBigInt64: {
			type: "Function",
			return: { type: "BigInt" }
		},
		getBigUint64: {
			type: "Function",
			return: { type: "BigInt" }
		},
		getFloat16: {
			type: "Function",
			return: { type: "Number" }
		},
		getFloat32: {
			type: "Function",
			return: { type: "Number" }
		},
		getFloat64: {
			type: "Function",
			return: { type: "Number" }
		},
		getInt16: {
			type: "Function",
			return: { type: "Number" }
		},
		getInt32: {
			type: "Function",
			return: { type: "Number" }
		},
		getInt8: {
			type: "Function",
			return: { type: "Number" }
		},
		getUint16: {
			type: "Function",
			return: { type: "Number" }
		},
		getUint32: {
			type: "Function",
			return: { type: "Number" }
		},
		getUint8: {
			type: "Function",
			return: { type: "Number" }
		},
		setBigInt64: { type: "Function" },
		setBigUint64: { type: "Function" },
		setFloat16: { type: "Function" },
		setFloat32: { type: "Function" },
		setFloat64: { type: "Function" },
		setInt16: { type: "Function" },
		setInt32: { type: "Function" },
		setInt8: { type: "Function" },
		setUint16: { type: "Function" },
		setUint32: { type: "Function" },
		setUint8: { type: "Function" },
		byteLength: { type: "Number" },
		byteOffset: { type: "Number" },
		buffer: { type: "ArrayBuffer" },
		[Symbol.toStringTag]: { type: "String" }
	},
	ArrayBuffer: {
		resize: { type: "Function" },
		slice: {
			type: "Function",
			return: { type: "ArrayBuffer" }
		},
		transfer: {
			type: "Function",
			return: { type: "ArrayBuffer" }
		},
		transferToFixedLength: {
			type: "Function",
			return: { type: "ArrayBuffer" }
		},
		byteLength: { type: "Number" },
		detached: { type: "Boolean" },
		maxByteLength: { type: "Number" },
		resizable: { type: "Boolean" },
		[Symbol.toStringTag]: { type: "String" }
	},
	SharedArrayBuffer: {
		grow: { type: "Function" },
		slice: {
			type: "Function",
			return: { type: "SharedArrayBuffer" }
		},
		byteLength: { type: "Number" },
		growable: { type: "Boolean" },
		maxByteLength: { type: "Number" },
		[Symbol.toStringTag]: { type: "String" },
		get [Symbol.species]() {
			return WELLKNOWN_GLOBALS.SharedArrayBuffer;
		}
	},
	WeakMap: {
		delete: RETURN_BOOLEAN,
		get: { type: "Function" },
		has: RETURN_BOOLEAN,
		set: { type: "Function" },
		[Symbol.toStringTag]: { type: "String" }
	},
	WeakSet: {
		add: { type: "Function" },
		delete: RETURN_BOOLEAN,
		has: RETURN_BOOLEAN,
		[Symbol.toStringTag]: { type: "String" }
	},
	Iterator: {
		next: { type: "Function" },
		return: { type: "Function" },
		throw: { type: "Function" },
		map: {
			type: "Function",
			return: { type: "Iterator" }
		},
		filter: {
			type: "Function",
			return: { type: "Iterator" }
		},
		take: {
			type: "Function",
			return: { type: "Iterator" }
		},
		drop: {
			type: "Function",
			return: { type: "Iterator" }
		},
		flatMap: {
			type: "Function",
			return: { type: "Iterator" }
		},
		reduce: { type: "Function" },
		toArray: {
			type: "Function",
			return: { type: "Array" }
		},
		forEach: { type: "Function" },
		some: RETURN_BOOLEAN,
		every: RETURN_BOOLEAN,
		find: { type: "Function" },
		[Symbol.iterator]: {
			type: "Function",
			return: { type: "Iterator" }
		},
		[Symbol.toStringTag]: { type: "String" },
		[Symbol.dispose]: { type: "Function" }
	},
	DisposableStack: {
		adopt: { type: "Function" },
		dispose: { type: "Function" },
		defer: { type: "Function" },
		disposed: { type: "Boolean" },
		move: {
			type: "Function",
			return: { type: "DisposableStack" }
		},
		use: { type: "Function" },
		[Symbol.toStringTag]: { type: "String" },
		[Symbol.dispose]: { type: "Function" }
	},
	AsyncDisposableStack: {
		adopt: {
			type: "Function",
			return: { type: "Promise" }
		},
		disposeAsync: { type: "Function" },
		defer: { type: "Function" },
		disposed: { type: "Boolean" },
		move: {
			type: "Function",
			return: { type: "AsyncDisposableStack" }
		},
		use: { type: "Function" },
		[Symbol.toStringTag]: { type: "String" },
		[Symbol.asyncDispose]: { type: "Function" }
	},
	WeakRef: {
		deref: { type: "Function" },
		[Symbol.toStringTag]: { type: "String" }
	},
	FinalizationRegistry: {
		register: { type: "Function" },
		unregister: RETURN_BOOLEAN,
		[Symbol.toStringTag]: { type: "String" }
	}
};
/**
* Returns the type information for a property of a given type.
*/
function getPropertyType(typeInfo, propertyName) {
	const prop = typeInfo.properties?.[propertyName];
	if (prop) return prop;
	const proto = typeInfo.type && WELLKNOWN_PROTOTYPE[typeInfo.type]?.[propertyName];
	if (proto) return proto;
	return OBJECT_PROTOTYPE[propertyName] ?? null;
}
/**
* Builds the type information for global typed arrays.
*/
function buildGlobalTypedArrayTypeInfo(type, otherProperties = {}) {
	return {
		type: "Function",
		return: { type },
		prototypeType: type,
		properties: {
			BYTES_PER_ELEMENT: { type: "Number" },
			from: {
				type: "Function",
				return: { type }
			},
			of: {
				type: "Function",
				return: { type }
			},
			...otherProperties
		}
	};
}
/**
* Builds the type information for typed array prototypes.
*/
function buildTypedArrayPrototypeTypeInfo(type, otherProperties = {}) {
	return {
		at: { type: "Function" },
		copyWithin: {
			type: "Function",
			return: { type }
		},
		entries: {
			type: "Function",
			return: { type: "Iterator" }
		},
		every: RETURN_BOOLEAN,
		fill: {
			type: "Function",
			return: { type }
		},
		filter: {
			type: "Function",
			return: { type }
		},
		find: { type: "Function" },
		findIndex: RETURN_NUMBER,
		findLast: { type: "Function" },
		findLastIndex: RETURN_NUMBER,
		forEach: { type: "Function" },
		includes: RETURN_BOOLEAN,
		indexOf: RETURN_NUMBER,
		join: RETURN_STRING,
		keys: {
			type: "Function",
			return: { type: "Iterator" }
		},
		lastIndexOf: RETURN_NUMBER,
		map: {
			type: "Function",
			return: { type }
		},
		reduce: { type: "Function" },
		reduceRight: { type: "Function" },
		reverse: {
			type: "Function",
			return: { type }
		},
		slice: {
			type: "Function",
			return: { type }
		},
		some: RETURN_BOOLEAN,
		sort: {
			type: "Function",
			return: { type }
		},
		toReversed: {
			type: "Function",
			return: { type }
		},
		toSorted: {
			type: "Function",
			return: { type }
		},
		values: {
			type: "Function",
			return: { type: "Iterator" }
		},
		with: {
			type: "Function",
			return: { type }
		},
		set: { type: "Function" },
		subarray: {
			type: "Function",
			return: { type }
		},
		valueOf: { type: "Function" },
		length: { type: "Number" },
		buffer: { type: "ArrayBuffer" },
		byteLength: { type: "Number" },
		byteOffset: { type: "Number" },
		[Symbol.iterator]: {
			type: "Function",
			return: { type: "Iterator" }
		},
		[Symbol.toStringTag]: { type: "String" },
		...otherProperties
	};
}

//#endregion
//#region src/type-tracer/get-property-key-value.ts
/**
* Get the property name/symbol from a MemberExpression node or a Property node.
*
* The difference from `@eslint-community/eslint-utils.getPropertyName()` is
* that if key is a Symbol, this function returns a Symbol.
* @param {Property|MemberExpression} node The node to get.
* @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.
* @returns {string|symbol|null}
*/
function getPropertyKeyValue(node, initialScope) {
	switch (node.type) {
		case "MemberExpression":
			if (node.computed) return getStaticKeyValue(node.property, initialScope);
			if (node.property.type === "PrivateIdentifier") return null;
			return node.property.name;
		case "Property":
		case "MethodDefinition":
		case "PropertyDefinition":
			if (node.computed) return getStaticKeyValue(node.key, initialScope);
			if (node.key.type === "Literal") return String(node.key.value);
			if (node.key.type === "PrivateIdentifier") return null;
			return node.key.name;
	}
	return null;
}
/**
* @param {Expression|PrivateIdentifier} node
* @param {Scope} initialScope
*/
function getStaticKeyValue(node, initialScope) {
	const value = getStaticValue(node, initialScope);
	return value && (typeof value.value === "symbol" ? value.value : String(value.value));
}

//#endregion
//#region src/type-tracer/type-tracer-for-es.ts
/**
* Build type tracer.
* @returns Returns a type tracer.
*/
function buildTypeTracerForES(sourceCode) {
	const getType = buildExpressionTypeProvider(sourceCode);
	return function(node) {
		const result = getSimpleExpressionType(node) || getType(node);
		return result != null ? [result] : [];
	};
}
/**
* Build type checker for ECMAScript.
*/
function buildTypeCheckerForES(sourceCode, aggressiveResult) {
	const tracer = buildTypeTracerForES(sourceCode);
	return (node, className) => {
		const typeNames = tracer(node);
		if (!typeNames.length) return aggressiveResult;
		return typeNames.includes(className);
	};
}
const cache = /* @__PURE__ */ new WeakMap();
/**
* Build expression type provider.
* @returns Returns an expression type provider.
*/
function buildExpressionTypeProvider(sourceCode) {
	const key = sourceCode.ast;
	let result = cache.get(key);
	if (!result) cache.set(key, result = buildExpressionTypeProviderImpl(sourceCode));
	return result;
}
/**
* Build expression type provider.
* @returns Returns an expression type provider.
*/
function buildExpressionTypeProviderImpl(sourceCode) {
	const GET_TYPE_INFOS = {
		ArrayExpression: () => ({ type: "Array" }),
		ObjectExpression: getObjectExpressionTypeInfo,
		FunctionDeclaration: getFunctionTypeInfo,
		ArrowFunctionExpression: getFunctionTypeInfo,
		FunctionExpression: getFunctionTypeInfo,
		Literal: (node) => ({ type: getSimpleExpressionType(node) }),
		TemplateLiteral: () => ({ type: "String" }),
		Identifier: getIdentifierTypeInfo,
		ImportExpression: () => ({ type: "Promise" }),
		MemberExpression: getMemberExpressionTypeInfo,
		BinaryExpression: (node) => getOperatorTypeInfo(node.operator, node.left, node.right),
		LogicalExpression: (node) => getOperatorTypeInfo(node.operator, node.left, node.right),
		AssignmentExpression: (node) => getOperatorTypeInfo(node.operator, node.left, node.right),
		UnaryExpression: getUnaryExpressionTypeInfo,
		UpdateExpression: () => ({ type: "Number" }),
		ClassExpression: () => ({ type: "Function" }),
		ChainExpression: (node) => getTypeInfo(node.expression),
		SequenceExpression: (node) => getTypeInfo(node.expressions[node.expressions.length - 1]),
		CallExpression: getCallExpressionTypeInfo,
		NewExpression: getCallExpressionTypeInfo,
		TaggedTemplateExpression: getCallExpressionTypeInfo,
		ConditionalExpression(node) {
			const consequent = getTypeInfo(node.consequent);
			const alternate = getTypeInfo(node.alternate);
			return {
				get type() {
					return consequent?.type === alternate?.type ? consequent?.type ?? null : null;
				},
				get return() {
					const t = consequent?.return?.type;
					if (t && t === alternate?.return?.type) return { type: t };
					return null;
				}
			};
		}
	};
	const trackedTypeInfo = /* @__PURE__ */ new Map();
	return (node) => getTypeInfo(node)?.type ?? null;
	/**
	* Gets the type info of the given node.
	* @param node The Expression node
	* @returns The type info of expression.
	*/
	function getTypeInfo(node) {
		if (trackedTypeInfo.has(node)) return trackedTypeInfo.get(node);
		trackedTypeInfo.set(node, null);
		try {
			const fn = GET_TYPE_INFOS[node.type];
			const result = fn?.(node) ?? null;
			trackedTypeInfo.set(node, result);
			return result;
		} catch {
			return null;
		}
	}
	/**
	* Finds the variable from the identifier node.
	* @param node The Identifier node.
	* @returns The variable or null if not found.
	*/
	function findVariableFromIdentifier(node) {
		return findVariable(sourceCode.scopeManager.globalScope, node);
	}
	/**
	* Gets the type info of the given identifier node.
	* @param node The Identifier node
	* @returns The type info of identifier.
	*/
	function getIdentifierTypeInfo(node) {
		const variable = findVariableFromIdentifier(node);
		if (!variable) return null;
		if (variable.defs.length === 0) return WELLKNOWN_GLOBALS[node.name] ?? null;
		if (variable.defs.length !== 1) return null;
		const def = variable.defs[0];
		if (def.type === "Variable") {
			if (def.node.init && def.parent.kind === "const") {
				const init = getTypeInfo(def.node.init);
				return init && getPatternTypeInfo(def.name, def.node.id, init);
			}
			if (def.parent.kind === "const") return null;
			return getAssignableVariableTypeInfo(variable);
		} else if (def.type === "FunctionName") return getTypeInfo(def.node);
		return null;
	}
	/**
	* Gets the type info of the assignable variable.
	* @param variable The variable to get type info.
	* @returns The type info of assignable variable or null if unknown.
	*/
	function getAssignableVariableTypeInfo(variable) {
		const typeInfos = [];
		for (const reference of variable.references) {
			if (!reference.writeExpr) continue;
			const parent = reference.writeExpr.parent;
			if (!parent) return null;
			if (parent.type === "VariableDeclarator") {
				if (reference.writeExpr !== parent.init) return null;
				const init = getTypeInfo(reference.writeExpr);
				if (!init) return null;
				const typeInfo = getPatternTypeInfo(reference.identifier, parent.id, init);
				if (!typeInfo) return null;
				typeInfos.push(typeInfo);
			} else if (parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") {
				if (reference.writeExpr !== parent.right) return null;
				const right = getTypeInfo(reference.writeExpr);
				if (!right) return null;
				const typeInfo = getPatternTypeInfo(reference.identifier, parent.left, right);
				if (!typeInfo) return null;
				typeInfos.push(typeInfo);
			} else return null;
		}
		const firstTypeInfo = typeInfos.shift();
		if (!firstTypeInfo) return null;
		if (!typeInfos.length) return firstTypeInfo;
		if (typeInfos.every((t) => t.type === firstTypeInfo.type)) return {
			type: firstTypeInfo.type,
			get return() {
				if (typeInfos.every((t) => t.return === firstTypeInfo.return)) return firstTypeInfo.return;
				return null;
			}
		};
		return null;
	}
	/**
	* Gets the type info of the given object expression node.
	* @param node The ObjectExpression node
	* @returns The type info of object expression.
	*/
	function getObjectExpressionTypeInfo(node) {
		let properties = null;
		return {
			type: "Object",
			get properties() {
				if (properties) return properties;
				properties = {};
				for (const prop of node.properties) {
					if (prop.type !== "Property") return properties = {};
					const propertyName = getPropertyKeyValue(prop, sourceCode.getScope(node));
					if (propertyName == null) continue;
					Object.defineProperty(properties, propertyName, { get() {
						return getTypeInfo(prop.value);
					} });
				}
				return properties;
			}
		};
	}
	/**
	* Gets the type info of the operator.
	* @param operator The operator to get type info.
	* @param leftNode The left node of the operator.
	* @param rightNode The right node of the operator.
	* @returns The type info of operator or null if unknown.
	*/
	function getOperatorTypeInfo(operator, leftNode, rightNode) {
		if (operator === "=") return getTypeInfo(rightNode);
		if (operator === "+" || operator === "+=") return getPlusOperatorTypeInfo(leftNode, rightNode);
		if (operator === "==" || operator === "!=" || operator === "===" || operator === "!==" || operator === "<" || operator === "<=" || operator === ">" || operator === ">=" || operator === "in" || operator === "instanceof") return { type: "Boolean" };
		if (operator === "-" || operator === "-=" || operator === "*" || operator === "*=" || operator === "/" || operator === "/=" || operator === "%" || operator === "%=" || operator === "^" || operator === "^=" || operator === "**" || operator === "**=" || operator === "&" || operator === "&=" || operator === "|" || operator === "|=") {
			const left = getTypeInfo(leftNode);
			const right = getTypeInfo(rightNode);
			if (left?.type === "BigInt" || right?.type === "BigInt") return { type: "BigInt" };
			return left?.type == null && right?.type == null ? null : { type: "Number" };
		}
		if (operator === "<<" || operator === "<<=" || operator === ">>" || operator === ">>=" || operator === ">>>" || operator === ">>>=") return { type: "Number" };
		if (operator === "&&" || operator === "&&=" || operator === "||" || operator === "||=" || operator === "??" || operator === "??=") {
			const left = getTypeInfo(leftNode);
			const right = getTypeInfo(rightNode);
			return left?.type && left.type === right?.type ? { type: left.type } : null;
		}
		return null;
	}
	/**
	* Gets the type info of the plus operator.
	* @param leftNode The left node of the plus operator.
	* @param rightNode The right node of the plus operator.
	* @returns The type info of plus operator or null if unknown.
	*/
	function getPlusOperatorTypeInfo(leftNode, rightNode) {
		const left = getTypeInfo(leftNode);
		const right = getTypeInfo(rightNode);
		if (left?.type === "String" || right?.type === "String") return { type: "String" };
		if (left?.type === "BigInt" || right?.type === "BigInt") return { type: "BigInt" };
		if (right?.type === "Number") return { type: "Number" };
		if (left?.type === "Number") {
			if (right?.type === "null" || right?.type === "undefined") return { type: "Number" };
		}
		if (right == null) return null;
		return { type: "String" };
	}
	/**
	* Gets the type info of the unary expression.
	* @param node The UnaryExpression node
	* @returns The type info of unary expression.
	*/
	function getUnaryExpressionTypeInfo(node) {
		if (node.operator === "!" || node.operator === "delete") return { type: "Boolean" };
		if (node.operator === "+") return { type: "Number" };
		if (node.operator === "-" || node.operator === "~") {
			const argument = getTypeInfo(node.argument);
			if (argument?.type === "BigInt") return { type: "BigInt" };
			return argument == null ? null : { type: "Number" };
		}
		if (node.operator === "typeof") return { type: "String" };
		if (node.operator === "void") return { type: "undefined" };
		return null;
	}
	/**
	* Gets the type info of the call expression.
	* @param node The CallExpression, NewExpression, or TaggedTemplateExpression node
	* @returns The type info of call expression.
	*/
	function getCallExpressionTypeInfo(node) {
		const callee = node.type === "CallExpression" || node.type === "NewExpression" ? node.callee : node.tag;
		return getTypeInfo(callee)?.return ?? null;
	}
	/**
	* Gets the type info of the function node.
	* @param node The FunctionExpression, ArrowFunctionExpression, or FunctionDeclaration node
	* @returns The type info of function.
	*/
	function getFunctionTypeInfo(node) {
		return {
			type: "Function",
			get return() {
				if (node.async) return { type: "Promise" };
				if (node.generator) return { type: "Iterator" };
				if (node.body.type !== "BlockStatement") return getTypeInfo(node.body);
				let returnStatement = null;
				for (const st of iterateReturn(node.body.body)) {
					if (!st.argument) continue;
					const argument = getTypeInfo(st.argument);
					if (!argument) return null;
					if (!returnStatement) returnStatement = argument;
					else if (returnStatement.type === argument.type) {
						const base = returnStatement;
						returnStatement = {
							type: base.type,
							get return() {
								const type1 = base.return?.type;
								const type2 = argument.return?.type;
								if (!type1 || !type2 || type1 !== type2) return null;
								return { type: type1 };
							}
						};
					} else return null;
				}
				return returnStatement;
				/**
				* Iterates through the statements and yields ReturnStatement nodes.
				*/
				function* iterateReturn(statements) {
					for (const statement of statements) if (statement.type === "ReturnStatement") yield statement;
					else if (statement.type === "BlockStatement") yield* iterateReturn(statement.body);
					else if (statement.type === "LabeledStatement" || statement.type === "WithStatement" || statement.type === "ForStatement" || statement.type === "ForInStatement" || statement.type === "ForOfStatement" || statement.type === "WhileStatement" || statement.type === "DoWhileStatement") yield* iterateReturn([statement.body]);
					else if (statement.type === "IfStatement") {
						yield* iterateReturn([statement.consequent]);
						if (statement.alternate) yield* iterateReturn([statement.alternate]);
					} else if (statement.type === "SwitchStatement") for (const caseClause of statement.cases) yield* iterateReturn(caseClause.consequent);
					else if (statement.type === "TryStatement") {
						yield* iterateReturn([statement.block]);
						if (statement.handler) yield* iterateReturn([statement.handler.body]);
						if (statement.finalizer) yield* iterateReturn([statement.finalizer]);
					}
				}
			}
		};
	}
	/**
	* Gets the type info of the member expression node.
	* @param node The MemberExpression node
	* @returns The type info of member expression.
	*/
	function getMemberExpressionTypeInfo(node) {
		const propertyName = getPropertyKeyValue(node, sourceCode.getScope(node));
		if (propertyName == null) return null;
		const object = getTypeInfo(node.object);
		if (!object) return null;
		if (propertyName === "prototype" && object.prototypeType) return { type: object.prototypeType };
		return getPropertyType(object, propertyName);
	}
	/**
	* Gets the type info of the pattern.
	* @param id The Identifier node.
	* @param pattern The pattern to get type info.
	* @param expression The expression to get type info.
	* @returns The type info of pattern or null if not found.
	*/
	function getPatternTypeInfo(id, pattern, expression) {
		if (pattern.type === "Identifier") return pattern === id ? expression : null;
		if (pattern.type === "ObjectPattern") {
			for (const prop of pattern.properties) {
				if (prop.type !== "Property") continue;
				const propertyName = getPropertyKeyValue(prop, sourceCode.getScope(pattern));
				if (propertyName == null) continue;
				const property = getPropertyType(expression, propertyName);
				if (property == null) continue;
				const patternType = getPatternTypeInfo(id, prop.value, property);
				if (patternType != null) return patternType;
			}
			return null;
		}
		if (pattern.type === "ArrayPattern") {
			for (const [index, entry] of pattern.elements.entries()) {
				if (!entry) continue;
				const indexType = getPropertyType(expression, index);
				if (indexType == null) continue;
				const patternType = getPatternTypeInfo(id, entry, indexType);
				if (patternType != null) return patternType;
			}
			return null;
		}
		if (pattern.type === "AssignmentPattern") return getPatternTypeInfo(id, pattern.left, expression);
		return null;
	}
}

//#endregion
//#region src/type-tracer/type-tracer.ts
/**
* Build type tracer.
* @param context The rule context.
* @returns Returns a type tracer.
*/
function buildTypeTracer(sourceCode) {
	return buildTypeTracerForTS(sourceCode) || buildTypeTracerForES(sourceCode);
}
/**
* Build type checker.
* @param context The rule context.
* @param aggressiveResult The value to return if the type cannot be determined.
* @returns Returns a type checker.
*/
function buildTypeChecker(sourceCode, options) {
	const aggressiveResult = options?.aggressive ? "aggressive" : false;
	return buildTypeCheckerForTS(sourceCode, aggressiveResult) || buildTypeCheckerForES(sourceCode, aggressiveResult);
}

//#endregion
export { buildTypeChecker, buildTypeTracer };